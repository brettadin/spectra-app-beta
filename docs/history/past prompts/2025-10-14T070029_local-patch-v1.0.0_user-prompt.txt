Timestamp (local): 2025-10-14T07:00:29
Timestamp (UTC): 2025-10-14T07:00:29Z
Patch ID / Version: local-patch-v1.0.0
Repository/Branch: spectra-app-beta/work
User Prompt (verbatim): **Start Implementation Prompt (with patch-prompt logging)**

Start implementation of the standalone Windows Spectra application using the provided documentation and fresh template as the sole sources of truth. Do not assume any folder or file paths beyond what the template and docs define, and do not rename or relocate anything.

You must also persist the **exact user prompt that initiated this work** as a per-patch record at:
`C:\Code\spectra-app-beta\docs\history\past prompts\`

If the folder does not exist, create it.

**Patch-Prompt Logging (required for every patch)**

1. At the start of this milestone, write a UTF-8 text file containing the exact user prompt you received (verbatim).
2. File name format:
   `YYYY-MM-DDTHHMMSS_local-patch-<semver-or-shortname>_user-prompt.txt`
   Example: `2025-10-14T010800_local-patch-v1.2.0_user-prompt.txt`
3. File contents (in this exact order):

   * `Timestamp (local)`: ISO 8601 local time.
   * `Timestamp (UTC)`: ISO 8601 UTC.
   * `Patch ID / Version`: the patch tag you are working under (or a short, unique ID if not set).
   * `Repository/Branch` (if relevant).
   * `User Prompt (verbatim)`: the full, unedited text from the user.
   * `Hash (SHA-256 of verbatim prompt)`: for provenance.
   * `Notes`: optional clarifications if the prompt arrived in multiple messages.
4. Reference this file path in your progress report for this milestone.

**Goals**

* Deliver a modern, responsive desktop app that preserves existing Spectra-App features as a baseline and is designed for future expansion.
* Enforce strict unit correctness, provenance, and non-destructive data handling.
* Keep costs near zero: prefer free or low-cost tooling.

**First milestone: Core platform + correctness**

1. **Read-in and plan**

   * Ingest the provided documentation. Produce a short written work plan that maps docs → components → tasks.
   * When the docs are ambiguous, choose a sensible default, proceed, and record the assumption in an “Assumptions & Open Questions” section of your progress report. Do not pause for confirmation.

2. **Select stack within constraints**

   * Choose a free/low-cost tech stack that fits the docs’ requirements. Record the decision and a brief rationale in your progress report (performance, packaging, UI quality, maintainability). Proceed with that choice.

3. **Implement core services (back end)**

   * **Units/Conversions Service:** Idempotent conversions with a canonical internal baseline; round-trip tests must return to the original baseline without drift.
   * **Data Ingest Service:** Pluggable parsers for common spectra sources and text/CSV-like formats. Parsing must capture metadata without mutating source values.
   * **Provenance Service:** Machine-readable manifests for every transform/export (sources, checksums, units, parameters, app version, timestamps, citations).
   * **Overlay/Compare Engine:** Multiple traces rendered together without altering originals; transform operations create derived views only.
   * **Differential/Math Ops:** A−B and A/B with epsilon protection when B≈0; trivial results (A=A) suppressed by default but logged.

4. **Minimal UI shell (front end)**

   * Build a clean, responsive shell that wires to the above services and supports: data ingest, unit selection/view, overlay controls, differential operations, provenance view, and basic status/notifications.
   * Ensure interactions apply on single, intentional actions; no double-click workarounds. Provide basic keyboard accessibility.

5. **Testing and samples**

   * Create unit tests for conversions, parsers, provenance writing, overlay integrity, and math ops (including epsilon handling and trivial-result suppression).
   * Include small sample datasets sufficient to exercise each feature. Do not hardcode any paths beyond the patch-prompt log directory above.

6. **Packaging and run**

   * Produce a runnable Windows build using whatever packaging flow the docs/template implies. Provide concise run instructions alongside the build artifacts.

7. **Progress outputs (no additional hardcoded paths)**

   * **Progress Report** with: work plan, decisions/rationales, assumptions/open questions, risks, and next steps.
   * **Feature Parity Checklist** noting which legacy behaviors are covered and what remains.
   * **Developer Notes** describing extension points for importers/transforms.
   * Include the full path to the **patch-prompt file** you wrote at the start.

**Quality bars**

* No silent data mutation; all transforms are explicit and logged.
* Conversions must be demonstrably correct and round-trip cleanly.
* UI actions should be deterministic and require a single user action.
* Document everything you implement at the level required for another agent to continue without rereading the code.

**End-of-milestone returnables**

* A runnable build of the app skeleton wired to the core services.
* All tests passing locally.
* The progress report, parity checklist, assumptions/open questions, developer notes, and the on-disk patch-prompt file path.

Begin now. Prioritize correctness, tests, and provenance over UI polish if you must trade off.
Hash (SHA-256 of verbatim prompt): dd6e8018fa37a7ef706405a32d3db1b64eff017162e682fa518287cc6095dd3a
Notes:
