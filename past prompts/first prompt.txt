**Prompt to start work**

Start implementation of the standalone Windows Spectra application using the provided documentation and fresh template as the sole sources of truth. Do not assume any folder or file paths beyond what the template and docs already define, and do not rename or relocate anything.

**Goals**

* Deliver a modern, responsive desktop app that preserves existing Spectra-App features as a baseline and is designed for future expansion.
* Enforce strict unit correctness, provenance, and non-destructive data handling.
* Keep costs near zero: prefer free or low-cost tooling.

**First milestone: Core platform + correctness**

1. **Read-in and plan**

   * Ingest the provided documentation. Produce a short written work plan that maps docs → components → tasks.
   * When the docs are ambiguous, choose a sensible default, proceed, and record the assumption in an “Assumptions & Open Questions” section of your progress report. Do not pause for confirmation.

2. **Select stack within constraints**

   * Choose a free/low-cost tech stack that fits the docs’ requirements. Record the decision and a brief rationale in your progress report (performance, packaging, UI quality, maintainability). Proceed with that choice.

3. **Implement core services (back end)**

   * **Units/Conversions Service:** Idempotent conversions with a canonical internal baseline; round-trip tests must return to the original baseline without drift.
   * **Data Ingest Service:** Pluggable parsers for common spectra sources and text/CSV-like formats. Parsing must capture metadata without mutating source values.
   * **Provenance Service:** Machine-readable manifests for every transform/export (sources, checksums, units, parameters, app version, timestamps, citations).
   * **Overlay/Compare Engine:** Multiple traces rendered together without altering originals; transform operations create derived views only.
   * **Differential/Math Ops:** A−B and A/B with epsilon protection when B≈0; trivial results (A=A) suppressed by default but log the event.

4. **Minimal UI shell (front end)**

   * Build a clean, responsive shell that wires to the above services and supports: data ingest, unit selection/view, overlay controls, differential operations, provenance view, and basic status/notifications.
   * Ensure interactions apply on single, intentional actions; no double-click workarounds. Accessibility and keyboard operation should function at a basic level.

5. **Testing and samples**

   * Create unit tests for conversions, parsers, provenance writing, overlay integrity, and math ops (including epsilon handling and trivial-result suppression).
   * Include small sample datasets sufficient to exercise each feature. Avoid altering template structure; place assets where the docs indicate.

6. **Packaging and run**

   * Produce a runnable Windows build using whatever packaging flow the docs/template implies. Provide concise run instructions alongside the build artifacts.

7. **Progress outputs (no hardcoded paths)**

   * Progress report with: work plan, decisions/rationales, assumptions/open questions, risks, and next steps.
   * Feature parity checklist noting which legacy behaviors are already covered and what remains.
   * Short “Developer Notes” describing extension points for importers/transforms.

**Quality bars**

* No silent data mutation. All transforms are explicit and logged.
* Conversions must be demonstrably correct and round-trip cleanly.
* UI actions should be deterministic and require a single user action.
* Document everything you implement at the level of detail needed for another agent to continue without re-reading the code.

**What to return at the end of this milestone**

* A runnable build of the app skeleton wired to the core services.
* Tests that pass locally.
* The progress report, parity checklist, assumptions/open questions, and developer notes.

Begin now. If you must make a tradeoff, prefer correctness, test coverage, and provenance over extra UI polish.
