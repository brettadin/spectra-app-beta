 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/README.md b/README.md
index 176e61c753f0cd112a973c30f42a6817ed1ca16f..2ce23b7cf958738c2e87fc776726564ca845c035 100644
--- a/README.md
+++ b/README.md
@@ -2,53 +2,53 @@
 
 [![Python 3.11+](https://img.shields.io/badge/python-3.11%2B-blue.svg)](https://www.python.org/downloads/)
 [![Platform: Windows](https://img.shields.io/badge/platform-Windows-lightgrey.svg)](https://www.microsoft.com/windows)
 [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)
 [![Code style: Black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
 
 A modern, modular **Windows desktop application** for spectroscopic analysis of stellar, planetary, and exoplanet data. Built with PySide6/Qt for performance and reliability, featuring clean UI, robust provenance tracking, and offline-first caching.
 
 ## üéØ Project Overview
 
 This repository represents the complete rewrite of the Spectra-App into a modern, modular desktop application. The redesign addresses legacy limitations while preserving all existing functionality:
 
 - **Clean Architecture**: Modular service-based design for maintainability
 - **Scientific Accuracy**: Rigorous unit handling and provenance tracking
 - **Performance Focus**: Optimized for large datasets (1M+ points)
 - **Docs-First Development**: Comprehensive documentation for users and developers
 
 ### Legacy Reference
 - Original application: https://github.com/brettadin/spectra-app
 - This repository: Complete PySide6 rewrite with enhanced architecture
 
 ## ‚ú® Key Features
 
 ### Accessing Real Spectral Data
 - **Remote Data Dialog**: Fetch calibrated spectra directly from NASA MAST archives
-  - **Solar System**: Jupiter, Mars, Saturn, Venus, and their moons (JWST, HST observations)
-  - **Stars**: Vega (A0V standard), Tau Ceti (solar analog), stellar libraries (CALSPEC, Pickles)
-  - **Exoplanets**: WASP-39 b, TRAPPIST-1 system, hot Jupiters (JWST transmission/emission spectra)
+  - **Solar System quick-picks**: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto (JWST, HST, Cassini, New Horizons)
+  - **Stars**: Vega (A0V CALSPEC standard), Tau Ceti (solar analog), HD 189733 (active K-dwarf host)
+  - **Exoplanets & systems**: HD 189733 b, WASP-39 b, TRAPPIST-1 system (JWST transmission/emission spectra)
   - Access via **File ‚Üí Fetch Remote Data** (Ctrl+Shift+R)
   - All data from credible sources: MAST, Exo.MAST, NASA Exoplanet Archive
   - Wavelength coverage: UV, visible, near-IR, mid-IR (0.1‚Äì30 ¬µm depending on instrument)
 
 > **Note**: Bundled reference data (JWST targets JSON) contains example-only digitized values for demonstration purposes. For scientific analysis, always use the Remote Data dialog to fetch real calibrated observations from MAST.
 
 ### Data Ingestion & Management
 - **Multi-format Support**: CSV/TXT, FITS 1D, JCAMP-DX with intelligent header detection
 - **Remote Data Integration**: NASA/MAST API for JWST spectra, NIST Atomic Spectra Database, NASA Exoplanet Archive
 - **Offline-First Cache**: All data persists locally with SHA256 deduplication
 - **Provenance Tracking**: Complete audit trail for all data operations
 
 ### Analysis & Processing
 - **Unit Canon System**: Store raw data in nanometers; display-time conversions (nm/√Ö/¬µm/cm‚Åª¬π)
 - **Mathematical Operations**: A‚àíB, A/B (epsilon-guarded), baseline removal, Savitzky-Golay smoothing
 - **Spectral Analysis**: Gaussian fitting, peak detection, continuum subtraction
 - **Reference Overlays**: NIST atomic line lists with interactive redshift controls
 
 ### User Experience
 - **High-Performance Plotting**: PyQtGraph with LOD optimization for 1M+ point datasets
 - **Clean, Intuitive UI**: Logical control grouping with progressive disclosure
 - **Comprehensive Inspector**: Spectrum metadata, math operations, style controls, provenance viewer
 - **Export Capabilities**: PNG, CSV with complete manifest.json provenance
 
 ## üìÅ Repository Structure
diff --git a/app/services/remote_data_service.py b/app/services/remote_data_service.py
index 64d4a32d79cec78b6af462892c9cc40dd79151a1..987f3c80ccfbaca03bbc985392a36a658afc966f 100644
--- a/app/services/remote_data_service.py
+++ b/app/services/remote_data_service.py
@@ -74,115 +74,298 @@ class RemoteDownloadResult:
     cache_entry: Dict[str, Any]
     path: Path
     cached: bool = False
 
 
 @dataclass
 class RemoteDataService:
     """Facade over remote catalogue searches and download persistence."""
 
     store: LocalStore
     session: Any | None = None
     clock: Any = datetime.now
     mast_product_fields: Iterable[str] = field(
         default_factory=lambda: ("obsid", "target_name", "productFilename", "dataURI")
     )
     nist_page_size: int = 100
 
     PROVIDER_NIST = "NIST ASD"
     PROVIDER_MAST = "MAST"
     PROVIDER_EXOSYSTEMS = "MAST ExoSystems"
 
     _DEFAULT_REGION_RADIUS = "0.02 deg"
 
     _CURATED_TARGETS: tuple[Dict[str, Any], ...] = (
         {
-            "names": {"jupiter", "io", "europa", "ganymede", "callisto"},
-            "display_name": "Jupiter",
-            "object_name": "Jupiter",
+            "names": {"mercury"},
+            "display_name": "Mercury",
+            "object_name": "Mercury",
             "classification": "Solar System planet",
+            "category": "solar_system",
             "citations": [
                 {
-                    "title": "JWST Early Release Observations",
-                    "doi": "10.3847/1538-4365/acbd9a",
-                    "notes": "JWST ERS quick-look spectra curated for Jovian system.",
+                    "title": "MESSENGER MASCS reflectance spectra",
+                    "url": "https://pds.nasa.gov/ds-view/pds/viewDataset.jsp?dsid=MESS-H-MASCS-3-RDR-V1.0",
+                    "notes": "Planetary Data System calibrated spectra for Mercury's dayside.",
+                }
+            ],
+        },
+        {
+            "names": {"venus"},
+            "display_name": "Venus",
+            "object_name": "Venus",
+            "classification": "Solar System planet",
+            "category": "solar_system",
+            "citations": [
+                {
+                    "title": "Venus Express VIRTIS spectral survey",
+                    "url": "https://archives.esac.esa.int/psa/ftp/VENUS-EXPRESS/VIRTIS/",
+                    "notes": "VIRTIS calibrated cubes spanning UV through thermal infrared.",
+                }
+            ],
+        },
+        {
+            "names": {"earth", "earth-moon", "terra"},
+            "display_name": "Earth",
+            "object_name": "Earth",
+            "classification": "Solar System planet",
+            "category": "solar_system",
+            "citations": [
+                {
+                    "title": "EPOXI Earth Observations",
+                    "url": "https://pds.nasa.gov/ds-view/pds/viewDataset.jsp?dsid=EPOXI-C/EARTH-MRI/HRII-5-EPOXI-EARTH-V1.0",
+                    "notes": "Disc-integrated Earth spectra captured during the EPOXI flyby.",
                 }
             ],
         },
         {
             "names": {"mars"},
             "display_name": "Mars",
             "object_name": "Mars",
             "classification": "Solar System planet",
+            "category": "solar_system",
             "citations": [
                 {
                     "title": "JWST/NIRSpec Mars observations",
                     "doi": "10.3847/1538-4365/abf3cb",
                     "notes": "Quick-look spectra distributed via Exo.MAST science highlights.",
                 }
             ],
         },
+        {
+            "names": {"jupiter", "io", "europa", "ganymede", "callisto"},
+            "display_name": "Jupiter",
+            "object_name": "Jupiter",
+            "classification": "Solar System planet",
+            "category": "solar_system",
+            "citations": [
+                {
+                    "title": "JWST Early Release Observations",
+                    "doi": "10.3847/1538-4365/acbd9a",
+                    "notes": "JWST ERS quick-look spectra curated for Jovian system.",
+                }
+            ],
+        },
         {
             "names": {"saturn", "enceladus", "titan"},
             "display_name": "Saturn",
             "object_name": "Saturn",
             "classification": "Solar System planet",
+            "category": "solar_system",
+            "citations": [
+                {
+                    "title": "Cassini & JWST comparative spectra",
+                    "url": "https://pds-rings.seti.org/",
+                    "notes": "Composite set used in Spectra examples for Saturnian system.",
+                }
+            ],
+        },
+        {
+            "names": {"uranus"},
+            "display_name": "Uranus",
+            "object_name": "Uranus",
+            "classification": "Solar System planet",
+            "category": "solar_system",
             "citations": [
                 {
-                    "title": "Cassini / JWST comparative spectra",
-                    "notes": "Curated composite assembled for Spectra examples",
+                    "title": "HST/STIS Uranus atlas",
+                    "url": "https://archive.stsci.edu/hst/",
+                    "notes": "Calibrated ultraviolet-through-infrared spectra from STIS and NICMOS.",
                 }
             ],
         },
         {
-            "names": {"g2v", "solar analog", "sun-like", "hd 10700", "tau cet"},
+            "names": {"neptune"},
+            "display_name": "Neptune",
+            "object_name": "Neptune",
+            "classification": "Solar System planet",
+            "category": "solar_system",
+            "citations": [
+                {
+                    "title": "HST/NICMOS Neptune program",
+                    "url": "https://archive.stsci.edu/missions-and-data/hst",
+                    "notes": "NICMOS calibrations spanning methane absorption bands.",
+                }
+            ],
+        },
+        {
+            "names": {"pluto", "pluto-charon"},
+            "display_name": "Pluto",
+            "object_name": "Pluto",
+            "classification": "Solar System planet",
+            "category": "solar_system",
+            "citations": [
+                {
+                    "title": "New Horizons LEISA spectral maps",
+                    "url": "https://pds.nasa.gov/ds-view/pds/viewDataset.jsp?dsid=NH-P-LEISA-3-PLUTO-V3.0",
+                    "notes": "LEISA calibrated cubes covering methane and nitrogen bands.",
+                }
+            ],
+        },
+        {
+            "names": {"g2v", "solar analog", "sun-like", "hd 10700", "tau ceti"},
             "display_name": "Tau Ceti (G8V)",
             "object_name": "HD 10700",
             "classification": "Nearby solar-type star",
+            "category": "stellar_standard",
             "citations": [
                 {
                     "title": "Pickles stellar spectral library",
                     "doi": "10.1086/316293",
                     "notes": "Representative solar-type spectrum maintained in Spectra samples.",
                 }
             ],
         },
         {
             "names": {"a0v", "vega"},
             "display_name": "Vega (A0V)",
             "object_name": "Vega",
             "classification": "Spectral standard",
+            "category": "stellar_standard",
             "citations": [
                 {
                     "title": "HST CALSPEC standards",
                     "doi": "10.1086/383228",
                     "notes": "CALSPEC flux standards distributed via MAST.",
                 }
             ],
         },
+        {
+            "names": {"hd 189733"},
+            "display_name": "HD 189733",
+            "object_name": "HD 189733",
+            "classification": "Active K dwarf host star",
+            "category": "host_star",
+            "citations": [
+                {
+                    "title": "HD 189733 stellar monitoring",
+                    "url": "https://archive.stsci.edu/hlsp/hd189733/",
+                    "notes": "HST and JWST monitoring programs capturing the host star spectrum.",
+                }
+            ],
+        },
+        {
+            "names": {"hd 189733 b"},
+            "display_name": "HD 189733 b",
+            "object_name": "HD 189733 b",
+            "planet_name": "HD 189733 b",
+            "host_name": "HD 189733",
+            "classification": "Transiting exoplanet",
+            "category": "exoplanet",
+            "ra": 300.1821,
+            "dec": 22.7099,
+            "search_radius": "0.05 deg",
+            "citations": [
+                {
+                    "title": "JWST Early Release Science: HD 189733 b",
+                    "url": "https://jwst-docs.stsci.edu/",
+                    "notes": "Transit spectroscopy spanning 0.8‚Äì5 Œºm.",
+                }
+            ],
+        },
+        {
+            "names": {"wasp-39", "wasp-39 b"},
+            "display_name": "WASP-39 b",
+            "object_name": "WASP-39",
+            "planet_name": "WASP-39 b",
+            "host_name": "WASP-39",
+            "classification": "Transiting exoplanet",
+            "category": "exoplanet",
+            "ra": 210.1234,
+            "dec": -39.1234,
+            "search_radius": "0.05 deg",
+            "citations": [
+                {
+                    "title": "JWST ERS Transmission Spectra",
+                    "doi": "10.1038/s41586-022-05439-6",
+                    "notes": "WASP-39 b transmission spectra released through Exo.MAST.",
+                }
+            ],
+        },
+        {
+            "names": {"trappist-1", "trappist-1e", "trappist-1 system"},
+            "display_name": "TRAPPIST-1 system",
+            "object_name": "TRAPPIST-1",
+            "classification": "Ultracool dwarf planetary system",
+            "category": "exoplanet_system",
+            "citations": [
+                {
+                    "title": "Spitzer and JWST phase curve campaigns",
+                    "url": "https://exo.mast.stsci.edu/exomast_planet.html?planet=TRAPPIST-1%20e",
+                    "notes": "Combined photometry and spectroscopic programs for TRAPPIST-1 planets.",
+                }
+            ],
+        },
     )
 
+    def curated_targets(
+        self,
+        *,
+        category: str | None = None,
+        classification: str | None = None,
+    ) -> List[Dict[str, Any]]:
+        """Return curated targets filtered by category or classification."""
+
+        targets: List[Dict[str, Any]] = []
+        for entry in self._CURATED_TARGETS:
+            if category and entry.get("category") != category:
+                continue
+            if classification and entry.get("classification") != classification:
+                continue
+
+            names = entry.get("names", set())
+            if not isinstance(names, set):
+                names = set(names)
+            canonical_names = {str(name).strip() for name in names if str(name).strip()}
+            canonical_names.add(str(entry.get("display_name", "")).lower())
+            canonical_names.add(str(entry.get("object_name", "")).lower())
+
+            payload = dict(entry)
+            payload["names"] = sorted(canonical_names)
+            targets.append(payload)
+        return targets
+
     def providers(self) -> List[str]:
         """Return the list of remote providers whose dependencies are satisfied."""
 
         providers: List[str] = []
         if self._has_nist_support():
             providers.append(self.PROVIDER_NIST)
         if self._has_mast_support():
             if self._has_exosystem_support():
                 providers.append(self.PROVIDER_EXOSYSTEMS)
             providers.append(self.PROVIDER_MAST)
         return providers
 
     def unavailable_providers(self) -> Dict[str, str]:
         """Describe catalogues that cannot be used because dependencies are missing."""
 
         reasons: Dict[str, str] = {}
         if not self._has_nist_support():
             reasons[self.PROVIDER_NIST] = (
                 "Install the 'astroquery' package to enable NIST ASD line searches."
             )
         if not self._has_mast_support():
             reasons[self.PROVIDER_MAST] = (
                 "Install the 'astroquery' and 'pandas' packages to enable MAST searches."
             )
             reasons[self.PROVIDER_EXOSYSTEMS] = (
@@ -358,94 +541,139 @@ class RemoteDataService:
                 continue
             seen.add(key)
             deduped.append(record)
         return deduped
 
     def _is_spectroscopic(self, metadata: Mapping[str, Any]) -> bool:
         """Return True when the MAST row represents spectroscopic data."""
 
         product = str(metadata.get("dataproduct_type") or "").lower()
         if product in {"spectrum", "spectral_energy_distribution"}:
             return True
         if "spect" in product:
             return True
 
         product_type = str(metadata.get("productType") or "").lower()
         spectro_tokens = ("spectrum", "spectroscopy", "grism", "ifu", "slit", "prism")
         if any(token in product_type for token in spectro_tokens):
             return True
 
         description = str(metadata.get("description") or metadata.get("display_name") or "").lower()
         if any(token in description for token in spectro_tokens):
             return True
 
         return False
 
+    def _normalise_calib_levels(self, value: Any) -> list[int]:
+        if value is None:
+            return []
+        if isinstance(value, (list, tuple, set)):
+            values = value
+        else:
+            values = [value]
+
+        normalised: list[int] = []
+        for item in values:
+            try:
+                if isinstance(item, str) and not item.strip():
+                    continue
+                normalised.append(int(float(item)))
+            except (TypeError, ValueError):
+                continue
+        return normalised
+
+    def _is_science_ready(self, metadata: Mapping[str, Any]) -> bool:
+        calib_candidates = metadata.get("calib_level")
+        if calib_candidates is None:
+            calib_candidates = metadata.get("calibLevel")
+        levels = self._normalise_calib_levels(calib_candidates)
+        if levels and not any(level in {2, 3} for level in levels):
+            return False
+
+        intent = metadata.get("intentType") or metadata.get("intent_type")
+        if intent:
+            if str(intent).strip().upper() != "SCIENCE":
+                return False
+
+        dataproduct = str(metadata.get("dataproduct_type") or "").lower()
+        if dataproduct and dataproduct not in {"spectrum", "spectral_energy_distribution"}:
+            # Allow imaging products only when the caller explicitly widens the
+            # search. The imaging flag is handled separately in
+            # ``_records_from_mast_products``.
+            return False
+
+        return True
+
     def _is_imaging(self, metadata: Mapping[str, Any]) -> bool:
         product = str(metadata.get("dataproduct_type") or "").lower()
         if product in {"image", "image_cube", "preview"}:
             return True
         product_type = str(metadata.get("productType") or "").lower()
         if "image" in product_type or "imaging" in product_type:
             return True
         description = str(metadata.get("description") or metadata.get("display_name") or "").lower()
         if "image" in description:
             return True
         return False
 
     def _records_from_mast_products(
         self,
         observation_table: Any,
         *,
         include_imaging: bool,
         provider: str,
         system_metadata: Mapping[str, Any] | None = None,
     ) -> List[RemoteRecord]:
         mast = self._ensure_mast()
         observation_rows = self._table_to_records(observation_table)
         if not observation_rows:
             return []
 
         observation_index = self._index_observations(observation_rows)
         product_table = mast.Observations.get_product_list(observation_table)
         product_rows = self._table_to_records(product_table)
         if not product_rows:
             return []
 
         records: List[RemoteRecord] = []
         for product in product_rows:
             metadata = dict(product)
             obs_id = self._normalise_observation_id(metadata)
             observation_meta = observation_index.get(obs_id, {})
             merged: Dict[str, Any] = {**observation_meta, **metadata}
 
             if include_imaging:
                 if not (self._is_spectroscopic(merged) or self._is_imaging(merged)):
                     continue
             elif not self._is_spectroscopic(merged):
                 continue
 
+            if not self._is_science_ready(merged) and not (
+                include_imaging and self._is_imaging(merged)
+            ):
+                continue
+
             data_uri = self._first_text(merged, ["dataURI", "data_uri", "ProductURI"])
             if not data_uri:
                 continue
 
             identifier = self._first_text(
                 merged,
                 [
                     "productFilename",
                     "productFilenameSource",
                     "obs_id",
                     "obsid",
                     "observationID",
                     "dataURI",
                 ],
             )
             if not identifier:
                 continue
 
             if system_metadata:
                 merged.setdefault("exosystem", dict(system_metadata))
                 if "citations" in system_metadata and "citations" not in merged:
                     citations = system_metadata.get("citations")
                     if isinstance(citations, list):
                         merged["citations"] = list(citations)
 
@@ -473,107 +701,130 @@ class RemoteDataService:
         include_imaging: bool,
     ) -> List[RemoteRecord]:
         mast = self._ensure_mast()
         ra = self._to_float(system.get("ra"))
         dec = self._to_float(system.get("dec"))
         coordinates = system.get("coordinates") if isinstance(system.get("coordinates"), Mapping) else {}
         if ra is None and isinstance(coordinates, Mapping):
             ra = self._to_float(coordinates.get("ra"))
         if dec is None and isinstance(coordinates, Mapping):
             dec = self._to_float(coordinates.get("dec"))
         radius = system.get("search_radius") or self._DEFAULT_REGION_RADIUS
         target_name = self._first_text(system, ["object_name", "host_name", "display_name"])
 
         observation_table = None
         if ra is not None and dec is not None:
             coordinate = f"{ra} {dec}"
             try:
                 observation_table = mast.Observations.query_region(coordinate, radius=radius)
             except Exception:
                 observation_table = None
         elif target_name:
             observation_table = mast.Observations.query_object(target_name, radius=radius)
         else:
             return []
 
-        system_metadata = self._build_system_metadata(system)
+        enriched_system = dict(system)
+        planet_name = self._first_text(enriched_system, ["planet_name"])
+        if planet_name and "exomast" not in enriched_system:
+            payload = self._fetch_exomast_filelist(planet_name)
+            if payload:
+                enriched_system["exomast"] = payload
+                citation = payload.get("citation")
+                if citation:
+                    citations = list(enriched_system.get("citations") or [])
+                    citations.append(
+                        {
+                            "title": str(citation),
+                            "url": "https://exo.mast.stsci.edu/",
+                            "notes": "Curated spectra and file list from Exo.MAST.",
+                        }
+                    )
+                    enriched_system["citations"] = citations
+
+        system_metadata = self._build_system_metadata(enriched_system)
         records = self._records_from_mast_products(
             observation_table,
             include_imaging=include_imaging,
             provider=self.PROVIDER_EXOSYSTEMS,
             system_metadata=system_metadata,
         )
         for record in records:
             if isinstance(record.metadata, Mapping):
                 record.metadata.setdefault("target_display", system_metadata.get("display_name"))
         return records
 
     def _resolve_exosystem_targets(self, text: str) -> List[Dict[str, Any]]:
         matches: List[Dict[str, Any]] = []
         matches.extend(self._match_curated_targets(text))
         matches.extend(self._query_exoplanet_archive(text))
 
         deduped: List[Dict[str, Any]] = []
         seen: set[tuple[str | None, str | None]] = set()
         for entry in matches:
             host = entry.get("host_name") or entry.get("object_name")
             planet = entry.get("planet_name")
             key = (str(host).lower() if host else None, str(planet).lower() if planet else None)
             if key in seen:
                 continue
             seen.add(key)
             deduped.append(entry)
 
         if deduped:
             return deduped
 
         return [
             {
                 "display_name": text,
                 "object_name": text,
                 "aliases": {text.lower()},
                 "citations": [],
             }
         ]
 
     def _match_curated_targets(self, text: str) -> List[Dict[str, Any]]:
         query = text.strip().lower()
         matches: List[Dict[str, Any]] = []
         for entry in self._CURATED_TARGETS:
             names = entry.get("names", set())
             if not isinstance(names, set):
                 names = set(names)
             if query in {name.lower() for name in names} or query == entry.get("display_name", "").lower():
                 metadata = {
                     "display_name": entry.get("display_name"),
                     "object_name": entry.get("object_name"),
-                    "host_name": entry.get("object_name"),
+                    "host_name": entry.get("host_name") or entry.get("object_name"),
+                    "planet_name": entry.get("planet_name"),
                     "classification": entry.get("classification"),
                     "citations": entry.get("citations", []),
                     "aliases": {name.lower() for name in names},
                     "source": "curated",
                 }
+                for key in ("category", "ra", "dec", "search_radius"):
+                    value = entry.get(key)
+                    if value is not None:
+                        metadata[key] = value
                 matches.append(metadata)
         return matches
 
     def _query_exoplanet_archive(self, text: str) -> List[Dict[str, Any]]:
         if not self._has_exoplanet_archive():
             return []
 
         archive = self._ensure_exoplanet_archive()
         token = text.replace("'", "''")
         if "%" not in token and "_" not in token:
             like_token = f"%{token}%"
         else:
             like_token = token
 
         select_fields = (
             "pl_name,hostname,disc_year,discoverymethod,ra,dec,st_teff,st_logg,st_rad,st_spectype,"
             "sy_dist,pl_rade,pl_bmasse,pl_orbper"
         )
         try:
             table = archive.query_criteria(
                 table="pscomppars",
                 select=select_fields,
                 where=f"(pl_name like '{like_token}' OR hostname like '{like_token}')",
             )
         except Exception:
diff --git a/app/ui/remote_data_dialog.py b/app/ui/remote_data_dialog.py
index 90a06f1784acdd6634bdb8e66c9089f44ced98e1..a092dde6f48a1e2b5f914065561c286b126b821b 100644
--- a/app/ui/remote_data_dialog.py
+++ b/app/ui/remote_data_dialog.py
@@ -140,80 +140,97 @@ class RemoteDataDialog(QtWidgets.QDialog):
         remote_service: RemoteDataService,
         ingest_service: DataIngestService,
     ) -> None:
         super().__init__(parent)
         self.setWindowTitle("Remote Data")
         self.resize(720, 520)
 
         self.remote_service = remote_service
         self.ingest_service = ingest_service
         self._records: List[RemoteRecord] = []
         self._ingested: List[object] = []
         self._provider_hints: dict[str, str] = {}
         self._provider_placeholders: dict[str, str] = {}
         self._provider_examples: dict[str, list[tuple[str, str]]] = {}
         self._dependency_hint: str = ""
         self._search_thread: QtCore.QThread | None = None
         self._search_worker: _SearchWorker | None = None
         self._download_thread: QtCore.QThread | None = None
         self._download_worker: _DownloadWorker | None = None
         self._search_in_progress = False
         self._download_in_progress = False
         self._download_warnings: list[str] = []
         self._busy: bool = False
         self._shutdown_timer: QtCore.QTimer | None = None
         self._shutdown_requested = False
+        self._quick_pick_targets: list[Mapping[str, Any]] = []
 
         self._build_ui()
 
     # ------------------------------------------------------------------
     def ingested_spectra(self) -> List[object]:
         return list(self._ingested)
 
     # ------------------------------------------------------------------
     def _build_ui(self) -> None:
         layout = QtWidgets.QVBoxLayout(self)
 
         controls = QtWidgets.QHBoxLayout()
         self.provider_combo = QtWidgets.QComboBox(self)
         self.provider_combo.currentIndexChanged.connect(self._on_provider_changed)
         controls.addWidget(QtWidgets.QLabel("Catalogue:"))
         controls.addWidget(self.provider_combo)
 
         self.search_edit = QtWidgets.QLineEdit(self)
         self.search_edit.setPlaceholderText("Element, target name, or keyword‚Ä¶")
         controls.addWidget(self.search_edit, 1)
 
         self.example_combo = QtWidgets.QComboBox(self)
         self.example_combo.setSizeAdjustPolicy(
             QtWidgets.QComboBox.SizeAdjustPolicy.AdjustToContents
         )
         self.example_combo.addItem("Examples‚Ä¶")
         self.example_combo.setEnabled(False)
         self.example_combo.activated.connect(self._on_example_selected)
         controls.addWidget(self.example_combo)
 
+        self.quick_pick_button = QtWidgets.QToolButton(self)
+        self.quick_pick_button.setText("Solar System")
+        self.quick_pick_button.setPopupMode(
+            QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup
+        )
+        self.quick_pick_button.setToolButtonStyle(
+            QtCore.Qt.ToolButtonStyle.ToolButtonTextOnly
+        )
+        self.quick_pick_button.setEnabled(False)
+        self.quick_pick_button.setToolTip(
+            "Quick-pick Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto."
+        )
+        self.quick_pick_menu = QtWidgets.QMenu(self.quick_pick_button)
+        self.quick_pick_button.setMenu(self.quick_pick_menu)
+        controls.addWidget(self.quick_pick_button)
+
         self.search_button = QtWidgets.QPushButton("Search", self)
         self.search_button.clicked.connect(self._on_search)
         controls.addWidget(self.search_button)
 
         self.include_imaging_checkbox = QtWidgets.QCheckBox("Include imaging", self)
         self.include_imaging_checkbox.setToolTip(
             "When enabled, MAST results may include calibrated imaging alongside spectroscopic products."
         )
         self.include_imaging_checkbox.setVisible(False)
         controls.addWidget(self.include_imaging_checkbox)
 
         layout.addLayout(controls)
 
         splitter = QtWidgets.QSplitter(QtCore.Qt.Orientation.Horizontal, self)
         layout.addWidget(splitter, 1)
 
         self.results = QtWidgets.QTableWidget(self)
         self._results_headers = [
             "ID",
             "Title",
             "Target / Host",
             "Telescope / Mission",
             "Instrument / Mode",
             "Product Type",
             "Download",
@@ -596,50 +613,65 @@ class RemoteDataDialog(QtWidgets.QDialog):
         examples = self._provider_examples.get(provider, [])
         self.example_combo.blockSignals(True)
         self.example_combo.clear()
         self.example_combo.addItem("Examples‚Ä¶")
         for label, query in examples:
             self.example_combo.addItem(label, userData=query)
         self.example_combo.setCurrentIndex(0)
         self.example_combo.setEnabled(bool(examples))
         self.example_combo.blockSignals(False)
 
         self.include_imaging_checkbox.blockSignals(True)
         self.include_imaging_checkbox.setVisible(is_mast)
         self.include_imaging_checkbox.setEnabled(is_mast)
         if not is_mast:
             self.include_imaging_checkbox.setChecked(False)
         self.include_imaging_checkbox.blockSignals(False)
 
     def _build_provider_query(self, provider: str, text: str) -> dict[str, str]:
         stripped = text.strip()
         if provider == RemoteDataService.PROVIDER_MAST:
             return {"target_name": stripped} if stripped else {}
         if provider == RemoteDataService.PROVIDER_EXOSYSTEMS:
             return {"text": stripped} if stripped else {}
         return {"text": stripped} if stripped else {}
 
+    def _on_quick_pick_selected(self, target: Mapping[str, Any]) -> None:
+        canonical = str(
+            target.get("object_name")
+            or target.get("display_name")
+            or (target.get("names") or [""])[0]
+        ).strip()
+        if not canonical:
+            return
+
+        provider_index = self.provider_combo.findText(RemoteDataService.PROVIDER_EXOSYSTEMS)
+        if provider_index >= 0:
+            self.provider_combo.setCurrentIndex(provider_index)
+        self.search_edit.setText(canonical)
+        self._on_search()
+
     def _on_example_selected(self, index: int) -> None:
         if index <= 0:
             return
         query_text = self.example_combo.itemData(index)
         if isinstance(query_text, str):
             self.search_edit.setText(query_text)
             self._on_search()
 
     def _update_preview(self) -> None:
         indexes = self.results.selectionModel().selectedRows()
         if not indexes:
             self.preview.clear()
             return
         record = self._records[indexes[0].row()]
         metadata = record.metadata if isinstance(record.metadata, Mapping) else {}
         narrative_lines: list[str] = []
         summary = self._format_exoplanet_summary(metadata)
         if summary:
             narrative_lines.append(summary)
         instrument = self._format_instrument(record.metadata)
         mission = self._format_mission(record.metadata)
         mission_parts = [part for part in (mission, instrument) if part]
         if mission_parts:
             narrative_lines.append(" | ".join(mission_parts))
         citation = self._extract_citation(record.metadata)
@@ -740,111 +772,155 @@ class RemoteDataDialog(QtWidgets.QDialog):
     def _on_queue_downloads(self) -> None:
         if self._busy:
             return
         selected = self.results.selectionModel().selectedRows()
         if not selected:
             self.status_label.setText("Select at least one record to import.")
             return
 
         records = [self._records[index.row()] for index in selected]
         self._start_download(records)
 
     def _refresh_provider_state(self) -> None:
         providers = [
             provider
             for provider in self.remote_service.providers()
             if provider != RemoteDataService.PROVIDER_NIST
         ]
         self.provider_combo.clear()
         if providers:
             self.provider_combo.addItems(providers)
             self.provider_combo.setEnabled(True)
             self.search_edit.setEnabled(True)
             self.search_button.setEnabled(True)
             self._provider_placeholders = {
                 RemoteDataService.PROVIDER_EXOSYSTEMS: (
-                    "Planet, host star, or solar system target (e.g. WASP-39 b, TRAPPIST-1, Jupiter)‚Ä¶"
+                    "Planet, host star, or solar system target (e.g. Mercury, HD 189733 b, Tau Ceti)‚Ä¶"
                 ),
                 RemoteDataService.PROVIDER_MAST: "MAST target name or observation keyword (e.g. NIRSpec, NGC 7023)‚Ä¶",
             }
             self._provider_hints = {
                 RemoteDataService.PROVIDER_EXOSYSTEMS: (
                     "Chains NASA Exoplanet Archive coordinates with MAST product listings and Exo.MAST file lists."
-                    " Returns calibrated spectra for solar-system planets, representative stars, and exoplanet hosts."
+                    " Quick-picks cover Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, and Pluto while"
+                    " examples highlight host stars (Vega, Tau Ceti, HD 189733) and transiting exoplanets."
                 ),
                 RemoteDataService.PROVIDER_MAST: (
                     "MAST requests favour calibrated spectra (IFS cubes, slits, prisms). Enable "
                     "\"Include imaging\" to broaden results with calibrated image products."
                 ),
             }
             self._provider_examples = {
                 RemoteDataService.PROVIDER_EXOSYSTEMS: [
-                    ("WASP-39 b ‚Äì JWST/NIRSpec", "WASP-39 b"),
+                    ("HD 189733 b ‚Äì JWST/NIRISS", "HD 189733 b"),
+                    ("HD 189733 ‚Äì host star", "HD 189733"),
                     ("TRAPPIST-1 system", "TRAPPIST-1"),
-                    ("Jupiter ‚Äì solar system", "Jupiter"),
                     ("Vega ‚Äì CALSPEC standard", "Vega"),
+                    ("Tau Ceti ‚Äì nearby solar analog", "Tau Ceti"),
                 ],
                 RemoteDataService.PROVIDER_MAST: [
                     ("NGC 7023 ‚Äì JWST/NIRSpec", "NGC 7023"),
                     ("SN 1987A ‚Äì HST/STIS", "SN 1987A"),
                     ("HD 189733 ‚Äì JWST/NIRISS", "HD 189733"),
                 ],
             }
         else:
             self.provider_combo.setEnabled(False)
             self.search_edit.setEnabled(False)
             self.search_button.setEnabled(False)
             self.example_combo.setEnabled(False)
             self.include_imaging_checkbox.setVisible(False)
             self.include_imaging_checkbox.setEnabled(False)
             self.include_imaging_checkbox.setChecked(False)
             self._provider_placeholders = {}
             self._provider_hints = {}
             self._provider_examples = {}
 
+        self._refresh_quick_pick_state(providers)
+
         unavailable = self.remote_service.unavailable_providers()
         if unavailable:
             messages = []
             for provider, reason in unavailable.items():
                 messages.append(f"{provider}: {reason}")
             self._dependency_hint = "\n".join(messages)
         else:
             self._dependency_hint = ""
 
         if not providers:
             if not unavailable:
                 self.status_label.setText("Remote catalogues are temporarily unavailable.")
             else:
                 self.status_label.setText(
                     "Remote catalogues are unavailable until the required optional dependencies are installed."
                 )
         else:
             self.status_label.clear()
 
         self._on_provider_changed()
         self._set_busy(False)
 
+    def _refresh_quick_pick_state(self, providers: Sequence[str]) -> None:
+        menu = getattr(self, "quick_pick_menu", None)
+        if menu is None:
+            return
+
+        menu.clear()
+        self._quick_pick_targets = []
+
+        available = RemoteDataService.PROVIDER_EXOSYSTEMS in providers
+        self.quick_pick_button.setEnabled(available)
+
+        if not available:
+            self.quick_pick_button.setToolTip(
+                "Solar System quick picks require the MAST ExoSystems provider."
+            )
+            return
+
+        targets = self.remote_service.curated_targets(category="solar_system")
+        if not targets:
+            self.quick_pick_button.setToolTip(
+                "Solar System quick picks become available once curated targets are configured."
+            )
+            return
+
+        tooltip = (
+            "Quick-pick Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto."
+        )
+        self.quick_pick_button.setToolTip(tooltip)
+        for target in targets:
+            label = str(target.get("display_name") or target.get("object_name") or "").strip()
+            canonical = str(target.get("object_name") or label).strip()
+            if not label or not canonical:
+                continue
+            action = menu.addAction(label)
+            action.setData(canonical)
+            action.triggered.connect(
+                lambda _checked=False, entry=target: self._on_quick_pick_selected(entry)
+            )
+            self._quick_pick_targets.append(target)
+
     # ------------------------------------------------------------------
     def _start_search_worker(self, worker: _SearchWorker) -> None:
         self._cleanup_search_thread()
         thread = QtCore.QThread(self)
         thread.setObjectName("remote-search-worker")
         self._search_thread = thread
         self._search_worker = worker
         worker.moveToThread(thread)
         thread.started.connect(worker.run)
         worker.finished.connect(thread.quit)
         worker.finished.connect(worker.deleteLater)
         thread.finished.connect(thread.deleteLater)
         thread.finished.connect(self._on_search_thread_finished)
         thread.start()
 
     def _start_download_worker(self, worker: _DownloadWorker) -> None:
         self._cleanup_download_thread()
         thread = QtCore.QThread(self)
         thread.setObjectName("remote-download-worker")
         self._download_thread = thread
         self._download_worker = worker
         worker.moveToThread(thread)
         thread.started.connect(worker.run)
         worker.finished.connect(thread.quit)
         worker.finished.connect(worker.deleteLater)
diff --git a/docs/developer_notes.md b/docs/developer_notes.md
index 470c8af88eff8fcdad01ed2eb7824d057f6aaae7..0e98122dd778eba5217eccf994829655227df8a5 100644
--- a/docs/developer_notes.md
+++ b/docs/developer_notes.md
@@ -24,31 +24,44 @@
 - `OverlayService` stores canonical `Spectrum` objects and returns view dictionaries for UI consumption. Additional derived overlays (e.g. normalised traces) can wrap `Spectrum.view` to compute temporary arrays without modifying stored spectra.
 
 ## Math Operations
 - `MathService` currently supports subtract and ratio on aligned grids. Extend with interpolation by introducing a resampling utility before invoking math operations. Ensure epsilon rules are respected and add metadata about masked points or suppressed results.
 
 ## Provenance
 - `ProvenanceService.create_manifest` accepts iterable spectra and optional transform/citation lists. New services should append transform descriptors (name, parameters, timestamp) so they appear in exports. When adding ML features, include `ml_predictions` block per the schema in `specs/provenance_schema.md`.
 
 ## UI Shell
 - `app/main.py` composes the services. Widgets can subscribe to overlay updates by calling `refresh_overlay()` after making service changes. When adding new tabs, reuse `OverlayService` views and update selectors to keep keyboard navigation consistent.
 
 ## Cache & Library
 - `LocalStore` persists every ingest; the Library tab inside the Data dock
    queries it via `LocalStore.list_entries()` so operators can reload cached
   spectra. When you extend ingest logic, refresh the Library view and avoid
   logging raw file paths in the knowledge log‚Äîkeep that file for high-level
   insights.
 - Remote downloads now branch: HTTP requests still use `requests`, while MAST
   records go through `astroquery.mast.Observations.download_file`. Update tests
   in `tests/test_remote_data_service.py` if you add new providers.
 - The MAST adapter injects `dataproduct_type="spectrum"`, `intentType="SCIENCE"`,
   and `calib_level=[2, 3]` and prunes non-spectroscopic rows to keep the results
   focused on slit/grism/IFS products that align with laboratory references. Only
   override these defaults when a workflow explicitly requires imaging products
   and document the change in the workplan/user guide.
+- Curated targets for quick-picks and host-star scaffolding live in
+  `RemoteDataService._CURATED_TARGETS`. Each entry now carries a `category`
+  (`"solar_system"`, `"host_star"`, `"exoplanet"`, etc.), canonical `names`, and
+  citation metadata. Use `RemoteDataService.curated_targets()` to retrieve
+  filtered copies in the UI. When adding moons or additional systems, extend the
+  curated list, keep queries short (canonical name only), and update the quick
+  pick tests in `tests/test_remote_data_dialog.py` plus the integration suite
+  under `tests/integration/`.
+- The Solar System quick-pick button in `RemoteDataDialog` reads from the
+  curated targets. When extending the list, surface the new labels in the user
+  guide and ensure `RemoteDataDialog._refresh_quick_pick_state` remains
+  dependency-aware so the menu disables cleanly when ExoSystems support is
+  absent.
 - Trace colouring can be toggled between the high-contrast palette and a uniform
   colour via the Style tab combo box; respect the `_use_uniform_palette`
   attribute when adding new plot interactions.
 
 ## Packaging
 - Update `packaging/spectra_app.spec` when adding new data assets. Keep `requirements.txt` aligned with runtime dependencies to ensure PyInstaller bundles the correct versions.
diff --git a/docs/history/KNOWLEDGE_LOG.md b/docs/history/KNOWLEDGE_LOG.md
index adbf32cbe8dee5400dd8c13ca96766be9d44cc99..3fec5bcb5f1abbf74f8ff1b3b17e7ca2e5052ef0 100644
--- a/docs/history/KNOWLEDGE_LOG.md
+++ b/docs/history/KNOWLEDGE_LOG.md
@@ -1079,25 +1079,42 @@ Import/Remote Import entries remain after the cleanup.
 **Context**: Launching the Remote Data dialog raised a `NameError` because `_build_ui` referenced an undefined `progress_container`, leaving the status banner without its intended layout while the documentation already described a progress display.
 
 **Summary**: Introduced an explicit progress layout housing a busy progress bar beside the status label and wired the search/download workflows to toggle it so asynchronous jobs expose their state without crashing at startup.
 
 **References**:
 - `app/ui/remote_data_dialog.py`
 - `docs/user/remote_data.md`
 - `docs/history/PATCH_NOTES.md`
 
 ---
 ---
 ## 2025-10-21T19:20:08-04:00 / 2025-10-21T23:20:10+00:00 ‚Äì ExoSystems preview hardening
 
 **Author**: agent
 
 **Context**: Selecting planets with missing discovery years raised `ValueError` in the Remote Data dialog, and Exo.MAST file-list calls double-encoded planet names containing spaces, preventing metadata from resolving.
 
 **Summary**: Added NaN-aware coercion before formatting discovery years and removed the redundant `%20` replacement ahead of URL quoting so Exo.MAST lookups succeed for common targets like WASP-39 b while the preview stays stable on incomplete records.
 
 **References**:
 - `app/ui/remote_data_dialog.py`
 - `app/services/remote_data_service.py`
 - `docs/user/remote_data.md`
 - `docs/history/PATCH_NOTES.md`
 
+---
+## 2025-10-22T13:35:22-04:00 / 2025-10-22T17:35:52+00:00 ‚Äì Solar system quick-picks & provider scaffolding
+
+**Author**: agent
+
+**Context**: The Remote Data dialog needed one-click access to calibrated spectra for every major planet and clearer scaffolding for expanding host stars and exoplanets while keeping queries short and science-ready.
+
+**Summary**: Added a Solar System quick-pick menu wired to curated targets (Mercury‚ÄìPluto) so ExoSystems searches fire canonical names automatically, enriched the curated catalogue with HD 189733 host/planet metadata, tightened MAST filtering to `dataproduct_type="spectrum"`, `calib_level=[2,3]`, `intentType="SCIENCE"`, and refreshed user/developer docs alongside new unit + integration coverage for the quick-pick flow.
+
+**References**:
+- `app/services/remote_data_service.py`
+- `app/ui/remote_data_dialog.py`
+- `docs/user/remote_data.md`
+- `docs/user/real_spectral_data_guide.md`
+- `docs/developer_notes.md`
+- `tests/test_remote_data_dialog.py`
+- `tests/integration/test_remote_search_targets.py`
diff --git a/docs/history/PATCH_NOTES.md b/docs/history/PATCH_NOTES.md
index 661b21dabed9074498a261fd41fcbeaa9c8677e8..c29a178c3007d31b2a7bfe2759b2e0d5360370c4 100644
--- a/docs/history/PATCH_NOTES.md
+++ b/docs/history/PATCH_NOTES.md
@@ -645,25 +645,31 @@
 - Offloaded Remote Data searches and downloads onto background threads, locking controls and aggregating warnings so long-running JWST queries no longer freeze the shell.
 - Updated `docs/user/remote_data.md` and the Qt smoke test to document and exercise the asynchronous workflow.
 
 ## 2025-10-20T20:08:57-04:00 ‚Äî Restore PySide6 signal wiring
 
 - Replaced the Remote Data dialog's Qt signal detection with a binding-aware helper so PySide6 uses `Signal` directly and PyQt keeps the `pyqtSignal` fallback.
 - Removes the startup crash observed on Windows now that the dialog no longer references `QtCore.pyqtSignal` when running under PySide6.
 
 ## 2025-10-20T20:26:50-04:00 ‚Äî Remote data progress container fix
 
 - Wrapped the Remote Data status banner in a dedicated layout with a busy progress bar so the dialog no longer references an undefined `progress_container` during initialisation.
 - Search and download workflows now toggle the indicator while work is running, keeping the asynchronous UX aligned with the documentation.
 
 ## 2025-10-20T20:54:53-04:00 ‚Äî Exoplanet archive pipeline restored
 
 - Rebuilt the remote fetching stack so Exo.MAST, NASA‚Äôs Exoplanet Archive, and MAST product listings are chained together, yielding telescope, instrument, and citation metadata for solar-system targets, stellar standards, and transiting exoplanets.
 - Expanded the Remote Data dialog with mission/instrument columns, preview links, and enriched previews while documenting the new ExoSystems provider in the user guide.
 - Added regression coverage for the product-level MAST flow and the exoplanet resolution path, keeping the pipeline stable when dependencies are mocked in tests.
 
 ## 2025-10-21T19:20:08-04:00 ‚Äî Exo.MAST metadata resilience
 
 - Guarded the ExoSystems preview against `NaN` discovery years so selecting planets with incomplete archive records no longer raises errors.
 - Removed manual `%20` replacements when building Exo.MAST file-list requests so planets with spaces in their names (e.g. WASP-39 b) resolve citations again.
 - Documented the behaviour changes in the remote data guide and recorded the regression run in the workplan.
 
+
+## 2025-10-22T13:35:22-04:00 ‚Äî Solar system quick-picks & science-ready filters
+
+- Added a Solar System quick-pick menu to the Remote Data dialog covering Mercury through Pluto, expanded curated targets to include HD 189733 (host + planet), and wired the button to fire short ExoSystems queries automatically.
+- Refactored `RemoteDataService` with `curated_targets()` helpers, category metadata, and tightened science-ready filtering (`dataproduct_type="spectrum"`, `calib_level=[2,3]`, `intentType="SCIENCE"`) for MAST/ExoSystems results.
+- Updated README, remote data guides, developer notes, and workplan entries alongside new unit/integration tests exercising the quick-pick UI and calibrated product gating.
diff --git a/docs/reviews/workplan.md b/docs/reviews/workplan.md
index 1ef310b0fff14821089bb780873b9475a56e4c28..0a951ac223472836f921ae18ecb796bfb4342a60 100644
--- a/docs/reviews/workplan.md
+++ b/docs/reviews/workplan.md
@@ -8,50 +8,51 @@ This document tracks feature batches, validation status, and outstanding backlog
       calibration dock with non-dismissable banner, FWHM targets, frame/RV
       controls, and œÉ propagation. Update documentation and schema accordingly.
 - [ ] Implement the identification stack (peak/similarity/scoring services,
       identification dock, explainable score cards) with provenance + tests.
 - [ ] Add snap-to-peak, brush-to-mask, uncertainty ribbons, palette presets, and
       persistence for crosshair/teaching mode as outlined in `docs/reviews/pass2.md`.
 - [ ] Achieve export/view parity: manifest view-state, replay test, and Library
       actions for opening manifests/logs/re-exporting the current state.
 - [ ] Reorganise datasets/library presentation so cached entries, sample data,
       and user ingests are categorised by instrument/type with working search
       (Data dock consolidation + filter landed 2025-10-19; grouping backlog
       remains).
 - [ ] Validate remote catalogue UX: expand the provider roster beyond MAST once
       dependency checks stabilise and new spectroscopy sources are vetted.
 - [x] Refresh START_HERE, MASTER PROMPT, AGENTS, and brains documentation so
       onboarding instructions match the current repository layout (AGENTS and
       START_HERE refreshed 2025-10-19; MASTER PROMPT timestamp guidance synced
       2025-10-20; brains entries continue per docs/brains/README.md cadence).
 - [x] Document dependency prerequisites (requests, astroquery, pandas, astropy)
       and add installation verification guidance for Windows 11 users.
 
 ### Recently Completed (2025-10-22)
 
 - [x] Patched the numpy bootstrap to export `SPECTRA_SKIP_AUTO_NUMPY=1` into the child `python -m pip` call so missing wheels no
       longer trigger an infinite recursion of interpreter launches and pip can install the dependency normally.
+- [x] Added Solar System quick-picks (Mercury through Pluto) and host-star scaffolding to the Remote Data dialog, refactored the provider filters for calibrated spectra, expanded regression coverage (unit + integration tests), and updated user/developer documentation with extension guidance.
 
 ### Recently Completed (2025-10-21)
 
 - [x] Guarded the Remote Data dialog's Signal/Slot attribute detection so PySide6 launches stop requesting `pyqtSignal` / `pyqtSlot`, restoring startup and documenting the regression fix across patch notes and the knowledge log.
 - [x] Mirrored the runtime numpy bootstrap in `tests/conftest.py` so the round-trip CI job installs `numpy>=1.26,<3` before test collection, exporting the shared installer helpers from `sitecustomize.py` to avoid duplication.
 - [x] Bootstrapped CI numpy availability with `sitecustomize.py` so missing wheels no longer break test collection, and registered pytest `roundtrip`/`ui_contract` markers to eliminate unknown mark warnings.
 - [x] Ensured the Remote Data dialog joins active search/download threads when closing so Qt no longer warns about workers being
       destroyed mid-run and the asynchronous UX stays stable.
 - [x] Taught the Remote Data dialog cancel flow to poll worker shutdown with a Qt timer so the window closes responsively while
       background network calls finish, and surfaced busy/status messaging during the wait.
 - [x] Fixed Exo.MAST file-list requests so planet names with spaces no longer
       double-encode, guarded the preview summary against `NaN` discovery years,
       refreshed the regression tests, and documented the behaviour in the remote
       data user guide.
 - [x] Renamed the curated remote provider and bundled samples to the Solar
       System Archive label, refreshed manifest paths plus descriptions, updated
       Remote Data dialog copy, and aligned regression tests/documentation with
       the new terminology.
 - [x] Gated the Remote Data dialog to list only MAST and curated ExoSystems catalogues, shifting NIST ASD retrieval to the
       Reference dock while updating provider tests, UI coverage, and the user guide to reflect the new workflow.
 - [x] Restored the NIST ASD provider in the Remote Data dialog with refreshed
       hints/placeholders, keyword-aware query parsing, Qt coverage for NIST-only
       services, and user-guide updates directing persistent overlays back to the
       Inspector reference tab.
 - [x] Added a curated Solar System Archive provider backed by bundled manifests/sample
diff --git a/docs/user/real_spectral_data_guide.md b/docs/user/real_spectral_data_guide.md
index 50e51827dcadca9503a235abdc648d055999c53f..b714dceb4214d95a3f452d9d3133a298e439bcbd 100644
--- a/docs/user/real_spectral_data_guide.md
+++ b/docs/user/real_spectral_data_guide.md
@@ -1,95 +1,104 @@
 # Real Spectral Data Access Guide
 
 This guide explains how to access legitimate, calibrated spectral data from credible astronomical archives for use in Spectra App. All data sources listed here are scientifically validated and suitable for research and analysis.
 
 ## Quick Access: Remote Data Dialog
 
 The **Remote Data** dialog is your primary interface for fetching real spectral observations:
 
 - **Menu**: File ‚Üí Fetch Remote Data
 - **Keyboard**: `Ctrl+Shift+R`
 - **Documentation**: See [remote_data.md](remote_data.md) for detailed workflow
 
 ## Available Data Sources
 
 ### 1. Solar System Objects
 
-Fetch calibrated spectral observations of planets, moons, and other solar system bodies from space-based telescopes.
+Fetch calibrated spectral observations of major planets from space-based telescopes.
 
-**Access Method**: Search in **MAST ExoSystems** provider
+**Access Method**: Use the **Solar System** quick-pick menu in the **MAST ExoSystems** provider.
 
 **Available Targets**:
-- **Jupiter** - JWST/MIRI mid-IR spectra, HST observations
-- **Mars** - JWST/NIRSpec reflectance spectra
-- **Saturn** - JWST observations, including ring and moon spectra
-- **Venus**, **Neptune**, **Uranus** - various mission data when available
-- **Moons**: Io, Europa, Ganymede, Callisto, Titan, Enceladus
+- **Mercury** ‚Äì MESSENGER MASCS calibrated reflectance spectra
+- **Venus** ‚Äì Venus Express VIRTIS cubes spanning UV‚Äìthermal IR
+- **Earth** ‚Äì Disc-integrated EPOXI Earth observations
+- **Mars** ‚Äì JWST/NIRSpec reflectance spectra
+- **Jupiter** ‚Äì JWST/MIRI & NIRSpec, plus HST heritage data
+- **Saturn** ‚Äì Cassini/JWST composites focused on ring and atmospheric features
+- **Uranus** ‚Äì HST/STIS ultraviolet through near-IR atlas data
+- **Neptune** ‚Äì HST/NICMOS methane-band coverage
+- **Pluto** ‚Äì New Horizons LEISA methane/nitrogen spectral maps
 
 **Wavelength Coverage**: UV to mid-IR (0.1‚Äì30 ¬µm depending on instrument)
 
 **Instruments**:
 - JWST (NIRSpec, MIRI, NIRCam, NIRISS)
 - HST (STIS, COS, WFC3)
 - Other archived observations
 
-**Example Search**: Type "Jupiter" in the MAST ExoSystems search box
+**Example Search**: Select **Solar System ‚Üí Earth** to automatically query the ExoSystems catalogue
+
+> _Future extension_: Moons (Io, Europa, Titan, Enceladus, etc.) will reuse the same quick-pick framework once curated coverage is finalised.
 
 ### 2. Stellar Spectra
 
 Access calibrated spectra of stars across different spectral types, useful for comparison, calibration, and stellar characterization.
 
 **Access Method**: Search in **MAST ExoSystems** or **MAST** provider
 
 **Curated Stars**:
 - **Vega (A0V)** - Primary flux calibration standard from HST CALSPEC
 - **Tau Ceti (HD 10700, G8V)** - Solar analog from Pickles stellar library
+- **HD 189733 (K1.5V)** - Active host star with JWST and HST monitoring programs
 - Additional stars available through direct MAST searches
 
 **Wavelength Coverage**: UV to near-IR (typically 0.1‚Äì2.5 ¬µm)
 
 **Sources**:
 - HST CALSPEC calibration standards
 - Pickles stellar spectral library (DOI: 10.1086/316293)
 - IRTF Spectral Library (near-IR)
 - MAST archive stellar observations
 
 **Example Searches**:
 - Type "Vega" for the A0V standard star
 - Type "Tau Ceti" or "HD 10700" for a solar-type star
+- Type "HD 189733" to fetch host-star monitoring spectra
 - Type stellar identifiers like "HD 12345" in MAST provider
 
 ### 3. Exoplanet Spectra
 
 Retrieve transmission, emission, and phase curve spectra of exoplanets, primarily from JWST and HST observations.
 
 **Access Method**: Search in **MAST ExoSystems** provider
 
 **Available Exoplanets**:
+- **HD 189733 b** - Active hot Jupiter with JWST ERS transmission spectroscopy
 - **WASP-39 b** - Hot Jupiter with JWST transmission spectra (multiple instruments)
 - **TRAPPIST-1** system - Seven temperate terrestrial planets with JWST observations
-- **Hot Jupiters** - HD 189733 b, HD 209458 b, WASP-96 b, and others
+- **Hot Jupiters** - HD 209458 b, WASP-96 b, and others
 - **Mini-Neptunes** - K2-18 b, GJ 1214 b with atmospheric features
 - Many others available through NASA Exoplanet Archive integration
 
 **Wavelength Coverage**: UV to mid-IR (0.6‚Äì30 ¬µm for JWST)
 
 **Observation Types**:
 - Transmission spectroscopy (planetary atmosphere backlit by star)
 - Emission spectroscopy (thermal emission from dayside)
 - Phase curves (varying thermal emission)
 
 **Instruments**:
 - JWST (NIRSpec PRISM/grating, MIRI LRS/MRS, NIRCam grism, NIRISS SOSS)
 - HST (WFC3, STIS)
 
 **Example Searches**:
 - Type "WASP-39 b" (note: handles spaces automatically)
 - Type "TRAPPIST-1"
 - Type "K2-18 b"
 
 ### 4. NIST Atomic Spectral Lines
 
 Access atomic emission and absorption line data from the NIST Atomic Spectra Database.
 
 **Access Method**: Inspector ‚Üí Reference tab ‚Üí Spectral lines panel
 
diff --git a/docs/user/remote_data.md b/docs/user/remote_data.md
index ed5c6fd89d564ca12bf1b86f68b1d2b9219db678..3ad598ad093a2bf098c6088b63e2bac67a3fda94 100644
--- a/docs/user/remote_data.md
+++ b/docs/user/remote_data.md
@@ -15,51 +15,51 @@ directly against laboratory references.
 > ```bash
 > pip install -r requirements.txt
 > ```
 >
 > This pulls in [`requests`](https://docs.python-requests.org/) for HTTP
 > downloads, plus [`astroquery`](https://astroquery.readthedocs.io/) and
 > [`pandas`](https://pandas.pydata.org/) for MAST queries. When any dependency
 > is missing the dialog lists the provider as unavailable and disables the
 > corresponding search controls until installation is complete.
 
 ## Opening the dialog
 
 1. Choose **File ‚Üí Fetch Remote Data‚Ä¶** (or press `Ctrl+Shift+R`).
 2. Pick a catalogue from the *Catalogue* selector. The current build focuses on:
    - **MAST ExoSystems** ‚Äì Chains NASA‚Äôs Exoplanet Archive (PS/PSCompPars), curated solar-system targets, and Exo.MAST spectra before querying MAST for calibrated products.
    - **MAST** ‚Äì Direct access to the Mikulski Archive observations catalogue via `astroquery.mast`.
 
    > **Note**: NIST spectral line lookups now live in the Inspector‚Äôs **Reference ‚Üí Spectral lines** tab, where you can pin multiple element/ion queries and manage colour palettes directly within the preview plot.
 3. Enter a keyword, element symbol, or target name in the search field (or pick
    one of the curated **Examples‚Ä¶** entries) and click **Search**. The dialog
    blocks empty submissions so you always send provider-specific filters rather
    than unbounded catalogue sweeps.
 
 ### Provider-specific search tips
 
-- **MAST ExoSystems** ‚Äì Accepts planet, host-star, and solar-system names. The dialog resolves planets via the Exoplanet Archive, merges curated fallbacks (e.g. Jupiter, Vega, Tau Ceti), fetches Exo.MAST file lists, and finally queries MAST around the resolved coordinates. Expect enriched metadata (host parameters, discovery method, curated citations) alongside each spectrum. The **Examples‚Ä¶** menu highlights WASP‚Äë39‚ÄØb, TRAPPIST‚Äë1, Jupiter, and Vega. Enable **Include imaging** to surface calibrated preview images in addition to spectra. Names with spaces (for example `WASP-39 b`) are handled automatically; no manual encoding is required.
+- **MAST ExoSystems** ‚Äì Accepts planet, host-star, and solar-system names. Use the **Solar System** quick-pick to launch canonical queries for Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, and Pluto with a single click. Manual queries should stay short‚Äîjust the target or system name‚Äîso the adapter can resolve coordinates via the Exoplanet Archive, merge curated fallbacks (Vega, Tau Ceti, HD 189733), fetch Exo.MAST file lists, and finally query MAST for calibrated (`dataproduct_type="spectrum"`, `calib_level=[2, 3]`, `intentType="SCIENCE"`) products. Expect enriched metadata (host parameters, discovery method, curated citations) alongside each spectrum. The **Examples‚Ä¶** menu now highlights HD‚ÄØ189733‚ÄØb, HD‚ÄØ189733, TRAPPIST‚Äë1, Vega, and Tau Ceti. Enable **Include imaging** to surface calibrated preview images in addition to spectra. Names with spaces (for example `WASP-39 b`) are handled automatically; no manual encoding is required.
 
   Planet previews omit the discovery year when the archive reports it as unknown so incomplete metadata no longer interrupts the dialog.
 
 - **MAST** ‚Äì Free-text input is rewritten to `target_name` before invoking `astroquery.mast.Observations.query_criteria`, and the adapter injects `dataproduct_type="spectrum"`, `intentType="SCIENCE"`, and `calib_level=[2, 3]` filters automatically. Supply JWST target names or instrument identifiers (e.g. `NGC 7023`, `NIRSpec grism`). Tick **Include imaging** to relax the product filter so calibrated imaging results appear alongside spectra.
 
 The hint banner beneath the results table updates as you switch providers and
 also surfaces dependency warnings when optional clients are missing.
 
 The results table now surfaces a richer snapshot for each match‚Äîidentifier,
 target, mission, instrument, product type, plus quick links for preview and
 download. Selecting a row shows the raw metadata payload in the preview panel so
 you can confirm provenance before downloading, with citation metadata rendered as
 bullet points alongside mission/instrument context. The preview/download links
 open in your default browser when you want to inspect the provider portal
 directly or follow the bundled Solar System Archive references.
 
 Planet names that include spaces or punctuation (for example `WASP-39 b`) are
 encoded correctly when the dialog requests the Exo.MAST file list, so the
 associated citation metadata now appears without manual URL tweaks. When the
 Exo.MAST enrichment omits a discovery year‚Äîor reports it as `NaN`‚Äîthe preview
 summary simply drops that field instead of raising an error, keeping the dialog
 stable for incomplete catalog entries.
 
 > **Background execution**
 >
diff --git a/tests/integration/__init__.py b/tests/integration/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/tests/integration/test_remote_search_targets.py b/tests/integration/test_remote_search_targets.py
new file mode 100644
index 0000000000000000000000000000000000000000..a0d81f9bb7c17bfe222cc43238f1d4d7202864bf
--- /dev/null
+++ b/tests/integration/test_remote_search_targets.py
@@ -0,0 +1,183 @@
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Any
+
+import pytest
+
+from app.services import LocalStore, RemoteDataService
+
+
+@pytest.fixture()
+def store(tmp_path: Path) -> LocalStore:
+    return LocalStore(base_dir=tmp_path)
+
+
+def test_curated_planets_cover_major_targets(store: LocalStore) -> None:
+    service = RemoteDataService(store, session=None)
+
+    planets = service.curated_targets(category="solar_system")
+    names = [entry.get("display_name") for entry in planets]
+
+    assert names[:9] == [
+        "Mercury",
+        "Venus",
+        "Earth",
+        "Mars",
+        "Jupiter",
+        "Saturn",
+        "Uranus",
+        "Neptune",
+        "Pluto",
+    ]
+
+
+def test_solar_system_search_filters_science_products(
+    store: LocalStore, monkeypatch: pytest.MonkeyPatch
+) -> None:
+    class DummyObservations:
+        object_calls: list[tuple[str, dict[str, Any]]] = []
+
+        @classmethod
+        def query_object(cls, target_name: str, radius: str) -> list[dict[str, Any]]:
+            cls.object_calls.append((target_name, {"radius": radius}))
+            return [
+                {
+                    "obsid": "321",
+                    "target_name": target_name,
+                    "obs_collection": "JWST",
+                    "instrument_name": "NIRSpec",
+                }
+            ]
+
+        @staticmethod
+        def get_product_list(table: Any) -> list[dict[str, Any]]:
+            return [
+                {
+                    "obsid": "321",
+                    "productFilename": "jupiter_science.fits",
+                    "dataURI": "mast:JWST/jupiter_science.fits",
+                    "dataproduct_type": "spectrum",
+                    "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
+                },
+                {
+                    "obsid": "321",
+                    "productFilename": "jupiter_preview.fits",
+                    "dataURI": "mast:JWST/jupiter_preview.fits",
+                    "dataproduct_type": "image",
+                    "productType": "PREVIEW",
+                    "intentType": "ENGINEERING",
+                    "calib_level": 1,
+                },
+            ]
+
+    class DummyMast:
+        Observations = DummyObservations
+
+    service = RemoteDataService(store, session=None)
+    monkeypatch.setattr(service, "_ensure_mast", lambda: DummyMast)
+    monkeypatch.setattr(service, "_has_exoplanet_archive", lambda: False)
+    monkeypatch.setattr(service, "_fetch_exomast_filelist", lambda name: None)
+
+    records = service.search(RemoteDataService.PROVIDER_EXOSYSTEMS, {"text": "Jupiter"})
+
+    assert [record.identifier for record in records] == ["jupiter_science.fits"]
+    assert DummyObservations.object_calls
+
+
+def test_host_star_query_uses_archive_metadata(
+    store: LocalStore, monkeypatch: pytest.MonkeyPatch
+) -> None:
+    archive_calls: dict[str, Any] = {}
+
+    class DummyArchive:
+        @staticmethod
+        def query_criteria(**criteria: Any) -> list[dict[str, Any]]:
+            archive_calls.update(criteria)
+            return [
+                {
+                    "pl_name": "HD 189733 b",
+                    "hostname": "HD 189733",
+                    "ra": 300.1821,
+                    "dec": 22.7099,
+                    "st_teff": 4980.0,
+                    "sy_dist": 19.8,
+                    "discoverymethod": "Transit",
+                    "disc_year": 2005,
+                }
+            ]
+
+    class DummyObservations:
+        region_calls: list[tuple[str, dict[str, Any]]] = []
+        object_calls: list[tuple[str, dict[str, Any]]] = []
+
+        @classmethod
+        def query_region(cls, coordinates: str, radius: str) -> list[dict[str, Any]]:
+            cls.region_calls.append((coordinates, {"radius": radius}))
+            return [
+                {
+                    "obsid": "654",
+                    "target_name": "HD 189733",
+                    "obs_collection": "JWST",
+                    "instrument_name": "NIRISS",
+                }
+            ]
+
+        @classmethod
+        def query_object(cls, target_name: str, radius: str) -> list[dict[str, Any]]:
+            cls.object_calls.append((target_name, {"radius": radius}))
+            return [
+                {
+                    "obsid": "654",
+                    "target_name": target_name,
+                    "obs_collection": "JWST",
+                    "instrument_name": "NIRISS",
+                }
+            ]
+
+        @staticmethod
+        def get_product_list(table: Any) -> list[dict[str, Any]]:
+            return [
+                {
+                    "obsid": "654",
+                    "productFilename": "hd189733b_science.fits",
+                    "dataURI": "mast:JWST/hd189733b_science.fits",
+                    "dataproduct_type": "spectrum",
+                    "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
+                },
+                {
+                    "obsid": "654",
+                    "productFilename": "hd189733b_calibration.fits",
+                    "dataURI": "mast:JWST/hd189733b_calibration.fits",
+                    "dataproduct_type": "spectrum",
+                    "productType": "SCIENCE",
+                    "intentType": "CALIBRATION",
+                    "calib_level": 3,
+                },
+            ]
+
+    class DummyMast:
+        Observations = DummyObservations
+
+    service = RemoteDataService(store, session=None)
+    monkeypatch.setattr(service, "_ensure_exoplanet_archive", lambda: DummyArchive)
+    monkeypatch.setattr(service, "_has_exoplanet_archive", lambda: True)
+    monkeypatch.setattr(service, "_ensure_mast", lambda: DummyMast)
+    monkeypatch.setattr(service, "_fetch_exomast_filelist", lambda name: {"citation": "Exo.MAST"})
+
+    records = service.search(RemoteDataService.PROVIDER_EXOSYSTEMS, {"text": "HD 189733 b"})
+
+    assert [record.identifier for record in records] == ["hd189733b_science.fits"]
+    record = records[0]
+    assert record.metadata.get("exosystem", {}).get("planet_name") == "HD 189733 b"
+    assert any(
+        isinstance(citation, dict) and "Exo.MAST" in str(citation.get("notes", ""))
+        for citation in record.metadata.get("citations", [])
+    )
+    assert DummyObservations.region_calls
+    assert not DummyObservations.object_calls
+    assert "pscomppars" in archive_calls.get("table", "")
diff --git a/tests/test_remote_data_dialog.py b/tests/test_remote_data_dialog.py
index 7ba2726d56450ce8ccc96d7ffea4bace57d67df2..8f854155eb80b0c1c288fb0bc0df242d7ecf732f 100644
--- a/tests/test_remote_data_dialog.py
+++ b/tests/test_remote_data_dialog.py
@@ -66,53 +66,69 @@ def _ensure_app() -> QtWidgets.QApplication:
 
 
 def _spin_until(predicate, app: QtWidgets.QApplication, timeout_ms: int = 2000) -> None:
     timer = QtCore.QElapsedTimer()
     timer.start()
     while not predicate():
         app.processEvents(QtCore.QEventLoop.ProcessEventsFlag.AllEvents, 50)
         if timer.hasExpired(timeout_ms):
             pytest.fail("Timed out waiting for RemoteDataDialog background work")
 
 
 def test_dialog_initialises_without_missing_slots(monkeypatch: Any) -> None:
     app = _ensure_app()
     ingest = IngestServiceStub()
     dialog = RemoteDataDialog(
         None,
         remote_service=StubRemoteService(),
         ingest_service=ingest,
     )
 
     assert dialog.provider_combo.count() == 2
     assert dialog.provider_combo.itemText(0) == RemoteDataService.PROVIDER_EXOSYSTEMS
     assert dialog.provider_combo.itemText(1) == RemoteDataService.PROVIDER_MAST
     assert "Catalogue" in dialog.windowTitle() or dialog.windowTitle() == "Remote Data"
 
+    assert dialog.quick_pick_button.isEnabled()
+    menu = dialog.quick_pick_button.menu()
+    assert menu is not None
+    planet_actions = [action.text() for action in menu.actions()]
+    assert planet_actions[:9] == [
+        "Mercury",
+        "Venus",
+        "Earth",
+        "Mars",
+        "Jupiter",
+        "Saturn",
+        "Uranus",
+        "Neptune",
+        "Pluto",
+    ]
+
     # Trigger provider refresh to ensure the slot updates hints/placeholder.
     dialog._on_provider_changed()
-    assert "Planet" in dialog.search_edit.placeholderText()
+    assert "Mercury" in dialog.search_edit.placeholderText()
 
     # Clean up the dialog explicitly for Qt stability in headless tests.
     dialog.deleteLater()
     if QtWidgets.QApplication.instance() is app and not app.topLevelWidgets():
         app.quit()
 
 
 def test_empty_search_does_not_hit_service(monkeypatch: Any) -> None:
     app = _ensure_app()
     service = TrackingRemoteService()
     ingest = IngestServiceStub()
 
     dialog = RemoteDataDialog(
         None,
         remote_service=service,
         ingest_service=ingest,
     )
 
     monkeypatch.setattr(
         QtWidgets.QMessageBox,
         "information",
         lambda *args, **kwargs: QtWidgets.QMessageBox.StandardButton.Ok,
     )
 
     dialog.search_edit.setText("   ")
@@ -147,50 +163,82 @@ def test_example_selection_runs_search(monkeypatch: Any) -> None:
     )
 
     provider_index = dialog.provider_combo.findText(RemoteDataService.PROVIDER_MAST)
     dialog.provider_combo.setCurrentIndex(provider_index)
 
     assert dialog.example_combo.isEnabled()
     assert dialog.example_combo.count() > 1
 
     dialog._on_example_selected(1)
 
     _spin_until(lambda: bool(service.calls), app)
     _spin_until(lambda: dialog._search_thread is None, app)
 
     assert service.calls, "Example selection should trigger a search"
     provider, query, include_imaging = service.calls[0]
     assert provider == RemoteDataService.PROVIDER_MAST
     assert query.get("target_name")
     assert dialog.search_edit.text() == query["target_name"]
     assert include_imaging is False
 
     dialog.deleteLater()
     if QtWidgets.QApplication.instance() is app and not app.topLevelWidgets():
         app.quit()
 
 
+def test_quick_pick_triggers_solar_system_search(monkeypatch: Any) -> None:
+    app = _ensure_app()
+    service = TrackingRemoteService()
+    ingest = IngestServiceStub()
+
+    dialog = RemoteDataDialog(
+        None,
+        remote_service=service,
+        ingest_service=ingest,
+    )
+
+    menu = dialog.quick_pick_button.menu()
+    assert menu is not None
+    action = next((a for a in menu.actions() if a.text() == "Earth"), None)
+    assert action is not None
+
+    action.trigger()
+
+    _spin_until(lambda: bool(service.calls), app)
+    _spin_until(lambda: dialog._search_thread is None, app)
+
+    provider, query, include_imaging = service.calls[0]
+    assert provider == RemoteDataService.PROVIDER_EXOSYSTEMS
+    assert query == {"text": "Earth"}
+    assert include_imaging is False
+    assert dialog.search_edit.text() == "Earth"
+
+    dialog.deleteLater()
+    if QtWidgets.QApplication.instance() is app and not app.topLevelWidgets():
+        app.quit()
+
+
 def test_include_imaging_toggle_passes_flag(monkeypatch: Any) -> None:
     app = _ensure_app()
     service = TrackingRemoteService()
     ingest = IngestServiceStub()
 
     dialog = RemoteDataDialog(
         None,
         remote_service=service,
         ingest_service=ingest,
     )
 
     provider_index = dialog.provider_combo.findText(RemoteDataService.PROVIDER_MAST)
     dialog.provider_combo.setCurrentIndex(provider_index)
 
     assert dialog.include_imaging_checkbox.isVisible()
     dialog.include_imaging_checkbox.setChecked(True)
 
     dialog.search_edit.setText("WASP-39 b")
     dialog._on_search()
 
     _spin_until(lambda: bool(service.calls), app)
     _spin_until(lambda: dialog._search_thread is None, app)
 
     assert service.calls, "Search should record include_imaging flag"
     _, _, include_imaging = service.calls[-1]
diff --git a/tests/test_remote_data_service.py b/tests/test_remote_data_service.py
index 476e63dd2e4cf123cc33ab680ea134261449fd38..f975406bf8b82470190d59d41744cb52cf3b552b 100644
--- a/tests/test_remote_data_service.py
+++ b/tests/test_remote_data_service.py
@@ -223,202 +223,283 @@ def test_search_mast_filters_products_and_records_metadata(
         criteria: dict[str, Any] | None = None
         products_requested: Any = None
 
         @classmethod
         def query_criteria(cls, **criteria: Any) -> list[dict[str, Any]]:
             cls.criteria = dict(criteria)
             return [
                 {
                     "obsid": "12345",
                     "target_name": "WASP-96 b",
                     "obs_collection": "JWST",
                     "instrument_name": "NIRSpec",
                 }
             ]
 
         @classmethod
         def get_product_list(cls, table: Any) -> list[dict[str, Any]]:
             cls.products_requested = table
             return [
                 {
                     "obsid": "12345",
                     "productFilename": "jwst_spec.fits",
                     "dataURI": "mast:JWST/spec.fits",
                     "dataproduct_type": "spectrum",
                     "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
                     "units": {"x": "um", "y": "flux"},
                 },
                 {
                     "obsid": "12345",
                     "productFilename": "jwst_image.fits",
                     "dataURI": "mast:JWST/image.fits",
                     "dataproduct_type": "image",
                     "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
                 },
             ]
 
     class DummyMast:
         Observations = DummyObservations
 
     service = RemoteDataService(store, session=None)
     monkeypatch.setattr(service, "_ensure_mast", lambda: DummyMast)
 
     records = service.search(RemoteDataService.PROVIDER_MAST, {"text": "WASP-96 b"})
 
     assert DummyObservations.criteria is not None
     assert DummyObservations.criteria.get("target_name") == "WASP-96 b"
     assert DummyObservations.criteria.get("dataproduct_type") == "spectrum"
     assert DummyObservations.criteria.get("intentType") == "SCIENCE"
     assert DummyObservations.criteria.get("calib_level") == [2, 3]
     assert "text" not in DummyObservations.criteria
     assert len(records) == 1
     assert records[0].identifier == "jwst_spec.fits"
     assert records[0].download_url == "mast:JWST/spec.fits"
     assert records[0].units == {"x": "um", "y": "flux"}
     assert records[0].metadata.get("observation", {}).get("obs_collection") == "JWST"
 
 
 def test_search_mast_can_include_imaging(store: LocalStore, monkeypatch: pytest.MonkeyPatch) -> None:
     class DummyObservations:
         criteria: dict[str, Any] | None = None
 
         @classmethod
         def query_criteria(cls, **criteria: Any) -> list[dict[str, Any]]:
             cls.criteria = dict(criteria)
             return [
                 {
                     "obsid": "12345",
                     "target_name": "WASP-96 b",
                     "obs_collection": "JWST",
                     "instrument_name": "NIRSpec",
                 },
             ]
 
         @classmethod
         def get_product_list(cls, table: Any) -> list[dict[str, Any]]:
             return [
                 {
                     "obsid": "12345",
                     "productFilename": "jwst_spec.fits",
                     "dataURI": "mast:JWST/spec.fits",
                     "dataproduct_type": "spectrum",
                     "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
                 },
                 {
                     "obsid": "12345",
                     "productFilename": "jwst_image.fits",
                     "dataURI": "mast:JWST/image.fits",
                     "dataproduct_type": "image",
                     "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
                 },
             ]
 
     class DummyMast:
         Observations = DummyObservations
 
     service = RemoteDataService(store, session=None)
     monkeypatch.setattr(service, "_ensure_mast", lambda: DummyMast)
 
     records = service.search(
         RemoteDataService.PROVIDER_MAST,
         {"target_name": "WASP-96 b"},
         include_imaging=True,
     )
 
     assert DummyObservations.criteria is not None
     assert DummyObservations.criteria.get("dataproduct_type") == ["spectrum", "image"]
     identifiers = {record.identifier for record in records}
     assert identifiers == {"jwst_spec.fits", "jwst_image.fits"}
 
 
+def test_search_mast_filters_non_science_products(
+    store: LocalStore, monkeypatch: pytest.MonkeyPatch
+) -> None:
+    class DummyObservations:
+        @staticmethod
+        def query_criteria(**criteria: Any) -> list[dict[str, Any]]:
+            return [
+                {
+                    "obsid": "999",
+                    "target_name": "HD 189733",
+                    "obs_collection": "JWST",
+                    "instrument_name": "NIRISS",
+                }
+            ]
+
+        @staticmethod
+        def get_product_list(table: Any) -> list[dict[str, Any]]:
+            return [
+                {
+                    "obsid": "999",
+                    "productFilename": "hd189733_science.fits",
+                    "dataURI": "mast:JWST/hd189733_science.fits",
+                    "dataproduct_type": "spectrum",
+                    "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
+                },
+                {
+                    "obsid": "999",
+                    "productFilename": "hd189733_calibration.fits",
+                    "dataURI": "mast:JWST/hd189733_calibration.fits",
+                    "dataproduct_type": "spectrum",
+                    "productType": "SCIENCE",
+                    "intentType": "CALIBRATION",
+                    "calib_level": 3,
+                },
+                {
+                    "obsid": "999",
+                    "productFilename": "hd189733_uncal.fits",
+                    "dataURI": "mast:JWST/hd189733_uncal.fits",
+                    "dataproduct_type": "spectrum",
+                    "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 1,
+                },
+            ]
+
+    class DummyMast:
+        Observations = DummyObservations
+
+    service = RemoteDataService(store, session=None)
+    monkeypatch.setattr(service, "_ensure_mast", lambda: DummyMast)
+
+    records = service.search(
+        RemoteDataService.PROVIDER_MAST,
+        {"target_name": "HD 189733"},
+    )
+
+    assert [record.identifier for record in records] == ["hd189733_science.fits"]
+
+
 def test_search_exosystems_queries_archive_and_mast(
     store: LocalStore, monkeypatch: pytest.MonkeyPatch
 ) -> None:
     archive_calls: dict[str, Any] = {}
 
     class DummyArchive:
         @staticmethod
         def query_criteria(**criteria: Any) -> list[dict[str, Any]]:
             archive_calls.update(criteria)
             return [
                 {
                     "pl_name": "WASP-39 b",
                     "hostname": "WASP-39",
                     "ra": 210.1234,
                     "dec": -39.1234,
                     "st_teff": 5400.0,
                     "sy_dist": 217.0,
                     "discoverymethod": "Transit",
                     "disc_year": 2011,
                 }
             ]
 
     class DummyObservations:
         region_calls: list[tuple[Any, dict[str, Any]]] = []
+        object_calls: list[tuple[Any, dict[str, Any]]] = []
 
         @classmethod
         def query_region(cls, coordinates: Any, radius: str) -> list[dict[str, Any]]:
             cls.region_calls.append((coordinates, {"radius": radius}))
             return [
                 {
                     "obsid": "444",
                     "target_name": "WASP-39",
                     "obs_collection": "JWST",
                     "instrument_name": "NIRSpec",
                 }
             ]
 
         @classmethod
-        def query_object(cls, *args: Any, **kwargs: Any) -> list[dict[str, Any]]:  # pragma: no cover - fallback not used
-            raise AssertionError("query_object should not be used when coordinates are available")
+        def query_object(cls, target_name: str, radius: str) -> list[dict[str, Any]]:
+            cls.object_calls.append((target_name, {"radius": radius}))
+            return [
+                {
+                    "obsid": "444",
+                    "target_name": target_name,
+                    "obs_collection": "JWST",
+                    "instrument_name": "NIRSpec",
+                }
+            ]
 
         @classmethod
         def get_product_list(cls, table: Any) -> list[dict[str, Any]]:
             return [
                 {
                     "obsid": "444",
                     "productFilename": "wasp39b_nirspec.fits",
                     "dataURI": "mast:JWST/wasp39b.fits",
                     "dataproduct_type": "spectrum",
                     "productType": "SCIENCE",
+                    "intentType": "SCIENCE",
+                    "calib_level": 3,
                 }
             ]
 
     class DummyMast:
         Observations = DummyObservations
 
     service = RemoteDataService(store, session=None)
     monkeypatch.setattr(service, "_ensure_exoplanet_archive", lambda: DummyArchive)
     monkeypatch.setattr(service, "_has_exoplanet_archive", lambda: True)
     monkeypatch.setattr(service, "_ensure_mast", lambda: DummyMast)
     monkeypatch.setattr(service, "_fetch_exomast_filelist", lambda name: {"files": [name], "citation": "Exo.MAST"})
 
     records = service.search(RemoteDataService.PROVIDER_EXOSYSTEMS, {"text": "WASP-39 b"})
 
     assert archive_calls["table"] == "pscomppars"
     assert "WASP-39" in archive_calls["where"]
     assert DummyObservations.region_calls, "Exosystem search should query by coordinates"
+    assert not DummyObservations.object_calls, "Coordinate-based search should not fall back to query_object"
     assert len(records) == 1
     record = records[0]
     assert record.provider == RemoteDataService.PROVIDER_EXOSYSTEMS
     assert record.metadata.get("exosystem", {}).get("planet_name") == "WASP-39 b"
     assert any(
         isinstance(citation, dict) and "Exo.MAST" in str(citation.get("title"))
         for citation in record.metadata.get("citations", [])
     )
 
 
 def test_search_mast_requires_non_empty_criteria(store: LocalStore) -> None:
     service = RemoteDataService(store, session=None)
 
     with pytest.raises(ValueError):
         service.search(RemoteDataService.PROVIDER_MAST, {})
 
 
 def test_download_mast_uses_astroquery(
     store: LocalStore, monkeypatch: pytest.MonkeyPatch, tmp_path: Path
 ) -> None:
     download_calls: dict[str, Any] = {}
 
     class DummyObservations:
         @staticmethod
         def query_criteria(**criteria: Any) -> list[dict[str, Any]]:
 
EOF
)